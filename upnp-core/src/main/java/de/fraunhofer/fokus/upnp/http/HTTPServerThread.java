/**
* 
* Copyright (C) 2004-2008 FhG Fokus
*
* This file is part of the FhG Fokus UPnP stack - an open source UPnP implementation
* with some additional features
*
* You can redistribute the FhG Fokus UPnP stack and/or modify it
* under the terms of the GNU General Public License Version 3 as published by
* the Free Software Foundation.
*
* For a license to use the FhG Fokus UPnP stack software under conditions
* other than those described here, or to purchase support for this
* software, please contact Fraunhofer FOKUS by e-mail at the following
* addresses:
*   upnpstack@fokus.fraunhofer.de
*
* The FhG Fokus UPnP stack is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program; if not, see <http://www.gnu.org/licenses/>
* or write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
*
*/
package de.fraunhofer.fokus.upnp.http;

import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.Socket;

import org.apache.log4j.Logger;

import de.fraunhofer.fokus.upnp.configuration.HTTPDefaults;
import de.fraunhofer.fokus.upnp.util.StringHelper;
import de.fraunhofer.fokus.upnp.util.ThreadHelper;
import de.fraunhofer.fokus.upnp.util.network.HTTPMessageObject;
import de.fraunhofer.fokus.upnp.util.network.IPHelper;

/**
 * This thread is created for each connected HTTP client. It reads the incoming request and forwards
 * it to the HTTP message processor. The response generated by the processor is then send back to
 * the requesting client.
 * 
 * @author tje, Alexander Koenig
 * 
 */
public class HTTPServerThread extends Thread
{

  /** HTTPServer logger */
  private final static Logger            logger                    = Logger.getLogger("upnp.http");

  /** Local endpoint of the connection */
  private Socket                         socket                    = null;

  /** Listener for incoming messages */
  private IHTTPMessageProcessor          messageProcessor          = null;

  /** Listener for incoming messages where the response should be streamed */
  private IHTTPStreamingMessageProcessor streamingMessageProcessor = null;

  /** Request */
  private HTTPMessageObject              request;

  /** Associated server */
  private HTTPServer                     httpServer;

  /** Address of the associated server */
  private InetSocketAddress              serverAddress;

  /** Flag to keep connection open if possible */
  private boolean                        persistentConnection      = false;

  /** Time of last received data */
  private long                           lastReceiveTime           = System.currentTimeMillis();

  /** Number of handled requests */
  private int                            requestCount              = 0;

  private boolean                        terminateThread           = false;

  private boolean                        terminated                = false;

  /**
   * Constructor of thread. The thread is not started.
   * 
   * @param httpServer
   *          The associated server
   * @param socket
   *          connection to client
   * @param messageProcessor
   *          The processor for the received message
   * 
   * @throws NullPointerException
   *           if socket or listener is null
   */
  public HTTPServerThread(HTTPServer httpServer, Socket socket, IHTTPMessageProcessor messageProcessor)
  {
    this(httpServer, socket, messageProcessor, false);
  }

  /**
   * Constructor of thread. The thread is not started.
   * 
   * @param httpServer
   *          The associated server
   * @param socket
   *          connection to client
   * @param messageProcessor
   *          The processor for the received message
   * @param persistent
   *          Flag that the client can possible answer multiple consecutive requests
   * 
   * @throws NullPointerException
   *           if socket or listener is null
   */
  public HTTPServerThread(HTTPServer httpServer,
    Socket socket,
    IHTTPMessageProcessor messageProcessor,
    boolean persistent)
  {
    super("HTTPServerThread [" + socket.toString() + "]");

    // System.out.println("Accepted connection from " + socket.getRemoteSocketAddress());

    this.socket = socket;
    this.persistentConnection = persistent;
    this.httpServer = httpServer;
    serverAddress = new InetSocketAddress(socket.getLocalAddress(), socket.getLocalPort());
    this.messageProcessor = messageProcessor;
    if (messageProcessor == null)
    {
      terminated = true;
      terminate();
      logger.error("No listener specified");
      throw new NullPointerException("listener");
    }
  }

  /**
   * Creates a new HTTPServer that handles connections with a streaming message processor. The
   * thread is not started.
   * 
   * @param httpServer
   *          The associated server
   * @param socket
   *          connection to client
   * @param streamingMessageProcessor
   *          The processor for the received message
   * @throws NullPointerException
   *           if socket or listener is null
   */
  public HTTPServerThread(HTTPServer httpServer, Socket socket, IHTTPStreamingMessageProcessor streamingMessageProcessor)
  {
    super("HTTPServerThread " + socket.toString());
    this.socket = socket;
    this.httpServer = httpServer;
    serverAddress = new InetSocketAddress(socket.getLocalAddress(), socket.getLocalPort());
    this.streamingMessageProcessor = streamingMessageProcessor;
    if (streamingMessageProcessor == null)
    {
      terminated = true;
      terminate();
      logger.error("No listener specified");
      throw new NullPointerException("listener");
    }
  }

  /**
   * Reads the incoming message and sends back the response.
   */
  public void run()
  {
    // read at least one message
    do
    {
      // busy waiting for received data
      boolean dataAvailable = false;
      // the thread is terminated after 5 minutes without data
      while (!terminateThread && !dataAvailable &&
        System.currentTimeMillis() - lastReceiveTime < HTTPDefaults.SERVER_THREAD_TIMEOUT)
      {
        try
        {
          dataAvailable = socket.getInputStream().available() > 0;
        } catch (Exception e)
        {
          System.out.println("Error checking available on socket input stream");
        }
        ThreadHelper.sleep(HTTPDefaults.SERVER_THREAD_SLEEP_TIME);
      }
      // data is available
      if (dataAvailable)
      {
        lastReceiveTime = System.currentTimeMillis();
        requestCount++;
        try
        {
          // create empty request with valid source and destination address
          request =
            new HTTPMessageObject(null, null, (InetSocketAddress)socket.getRemoteSocketAddress(), serverAddress);

          socket.setSoTimeout(20);
          // always read the whole request
          HTTPMessage.getServerMessage(request, socket.getInputStream());
          // check if request is valid
          if (request.getHeader() != null && request.getHeader().length() != 0)
          {
            // System.out.println("HTTP server thread [" +
            // IPAddress.toString((InetSocketAddress)socket.getLocalSocketAddress()) +
            // " <- " + IPAddress.toString((InetSocketAddress)socket.getRemoteSocketAddress()) +
            // "] received request: " + request.getHeader());

            // check whether the request should be received in one piece or in chunks
            if (messageProcessor != null)
            {
              // process all in one piece
              if (!persistentConnection)
              {
                System.out.println("HTTP server thread [" +
                  IPHelper.toString((InetSocketAddress)socket.getLocalSocketAddress()) + " <- " +
                  IPHelper.toString((InetSocketAddress)socket.getRemoteSocketAddress()) +
                  "]: Close connection due to server setup");
                persistentConnection = false;
                request.setCloseConnection(true);
              }
              HTTPMessageObject response = messageProcessor.processMessage(request);
              if (response == null)
              {
                sendHTTPError();
              } else
              {
                // System.out.println("HTTP server thread [" +
                // IPAddress.toString((InetSocketAddress)socket.getLocalSocketAddress()) +
                // " <- " + IPAddress.toString((InetSocketAddress)socket.getRemoteSocketAddress()) +
                // "] generated response: " + response.getHeader());

                sendResponse(response);
                if (response.isCloseConnection())
                {
                  System.out.println("HTTP server thread [" +
                    IPHelper.toString((InetSocketAddress)socket.getLocalSocketAddress()) + " <- " +
                    IPHelper.toString((InetSocketAddress)socket.getRemoteSocketAddress()) +
                    "]: Close connection due to \"Connection: Close\" in client request");
                  persistentConnection = false;
                }
              }
            }
            if (streamingMessageProcessor != null)
            {
              request.setCloseConnection(true);
              // process response in chunks and send data as soon as it is available
              HTTPMessageObject response = streamingMessageProcessor.processMessage(serverAddress, request);
              if (response == null)
              {
                sendHTTPError();
              } else
              {
                sendResponse(response);
                // read data in chunks
                byte[] buffer = new byte[65536];
                int bytesRead = streamingMessageProcessor.readConsecutiveResponseBody(buffer, 1000);
                while (bytesRead != -1)
                {
                  // send newly received data
                  sendResponseData(buffer, bytesRead);
                  bytesRead = streamingMessageProcessor.readConsecutiveResponseBody(buffer, 1000);
                }
              }
            }
          } else
          {
            System.out.println("Could not receive request");
            persistentConnection = false;
          }
        } catch (Exception ex)
        {
          logger.error("Failed to process message", ex);
          persistentConnection = false;
        } catch (OutOfMemoryError mem)
        {
          logger.error("Client request too huge", mem);
          persistentConnection = false;
        }
      } else
      {
        if (!terminateThread)
        {
          // System.out.println("End life time of HTTP server thread on port " +
          // socket.getLocalPort() + ", handled " + requestCount + " request(s)");
        }
        persistentConnection = false;
      }
      ThreadHelper.sleep(50);
    }
    // terminate if idle for a certain time
    while (!terminateThread && persistentConnection &&
      System.currentTimeMillis() - lastReceiveTime < HTTPDefaults.SERVER_THREAD_TIMEOUT);

    logger.info("Terminate HTTP server thread [" +
      IPHelper.toString((InetSocketAddress)socket.getLocalSocketAddress()) + " <- " +
      IPHelper.toString((InetSocketAddress)socket.getRemoteSocketAddress()) + "]");

    // System.out.println("Terminate HTTP server thread [" +
    // IPAddress.toString((InetSocketAddress)socket.getLocalSocketAddress()) +
    // " <- " + IPAddress.toString((InetSocketAddress)socket.getRemoteSocketAddress()) +
    // "]");

    // prevent deadlock
    terminated = true;
    terminate();
    httpServer.connectionDone(this);
  }

  /** This methods sends an error message for empty responses */
  private void sendHTTPError()
  {
    logger.error("no message to be sent");
    byte[] errorMessage = StringHelper.stringToByteArray(HTTPHeaderBuilder.buildHTTPError5xx());
    try
    {
      socket.getOutputStream().write(errorMessage);
    } catch (IOException e)
    {
      logger.error("response message cannot be send to " + socket.getInetAddress());
      logger.error("reason: " + e.getMessage());
    }
  }

  /**
   * This method sends a response message.
   * 
   * @param response
   *          The response message
   */
  private void sendResponse(HTTPMessageObject response)
  {
    // System.out.println("Send response [\n" +
    // StringHelper.byteArrayToString(clientResponseMessage) + "]");
    byte[] responseData = response.toByteArray();

    try
    {
      socket.getOutputStream().write(responseData);

      // logger.debug("Send response [\n" + response.getHeader() + "\n" + response.getBodyAsString()
      // +
      // "]\n" + responseData.length + " bytes to " + socket.getInetAddress());
    } catch (IOException e)
    {
      logger.error("response message cannot be send to " + socket.getInetAddress());
      logger.error("reason: " + e.getMessage());
    }
  }

  /**
   * This method sends some bytes from a streamed response message.
   * 
   * @param data
   *          The data buffer
   * @param length
   *          The number of bytes that should be sent
   */
  private void sendResponseData(byte[] data, int length)
  {
    try
    {
      socket.getOutputStream().write(data, 0, length);
    } catch (IOException e)
    {
      logger.error("response message cannot be send to " + socket.getInetAddress());
      logger.error("reason: " + e.getMessage());
    }
  }

  /** This method closes the server thread. */
  public void terminate()
  {
    terminateThread = true;
    while (!terminated)
    {
      ThreadHelper.sleep(50);
    }
    try
    {
      if (socket != null)
      {
        if (socket.getInputStream() != null)
        {
          socket.getInputStream().close();
        }

        if (socket.getOutputStream() != null)
        {
          socket.getOutputStream().close();
        }

        socket.close();
        socket = null;
      }
    } catch (Exception e)
    {
    }
  }
}
